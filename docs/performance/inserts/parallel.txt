.. _concurrent_inserts:

================
Parallel Inserts
================

If you have a queue of inserts, one way to process them in your client is to
send them one by one, waiting for the response from previous insert before
sending the next one.

With a latency of 5ms between the server and client, even if inserts happened
instantaneously, this client could only ever do 200 inserts per second.

If you're handling a lot of inserts, this sort of setup can very quickly become
a performance bottleneck.

The solution to this is to send multiple inserts concurrently. That is, send
off every insert request as soon as you need to and do not wait for a
response before sending another insert.

.. rubric:: Table of Contents

.. contents::
   :local:

Example
=======

Suppose we have a stream of data we want to persist into CrateDB.
Parallelising this processing in Java is possible using a
`CompletableFuture`_ object, like so:

.. _CompletableFuture: https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html

.. code-block:: java

    IntStream.iterate(0, i -> i + 2)
        .limit(1000)
        .forEach(i -> {
            CompletableFuture<Integer> insertFuture =
                CompletableFuture.supplyAsync(() -> {
                    try {
                        PreparedStatement stmt =
                          connection.prepareStatement("INSERT INTO my_table VALUES (?)");
                        stmt.setInt(1, i);
                        return stmt.executeUpdate();
                    } catch (SQLException e) {
                        throw new RuntimeException(e);
                    }
                });

            insertFuture.whenComplete((Integer result, Throwable failure) -> {
                if (failure == null) {
                    // use row count
                } else {
                    // handle insert failure
                }
            });
        });

This way, the inserts will be executed asynchronously by the 
`commmonPool`_ object. You can provide your own ``Executor`` object using the 
appropriate `supplyAsync`_ signature.

.. _commmonPool: https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinPool.html#commonPool--
.. _supplyAsync: https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html#supplyAsync-java.util.function.Supplier-java.util.concurrent.Executor-

Testing
=======

Follow the instructions in our :ref:`testing_inserts_performance` guide.

To test parallel inserts, you should:

1. Configure the setup you would like to test

2. Run a number of different tests against that setup, using different
   ``--concurrency`` settings

3. Evaluate your throughput results (perhaps by plotting your results on
   a graph so that you can see the response curve)

Try out different setups and re-run the test.

At the end of this process, you will have a better understanding of the
throughput of your cluster with different setups and under different loads.

.. _HAProxy: http://www.haproxy.org/
.. _A record: https://en.wikipedia.org/wiki/List_of_DNS_record_types?
.. _Python client: https://crate.io/docs/clients/python/en/latest/
.. _JDBC client: https://crate.io/docs/clients/jdbc/en/latest/
.. _PHP PDO client: https://crate.io/docs/clients/pdo/en/latest/
.. _HikariCP: https://github.com/brettwooldridge/HikariCP
